const fs = require("node:fs");
const path = require("node:path");

const root = path.join(__dirname, "..");
const nm = (p) => path.join(root, "node_modules", p);

// candidate platform packages (extend if you need other targets)
const candidates = [
  "lightningcss-win32-x64-msvc",
  "lightningcss-win32-arm64-msvc",
  "lightningcss-linux-x64-gnu",
  "lightningcss-linux-x64-musl",
  "lightningcss-darwin-x64",
  "lightningcss-darwin-arm64",
];

// pick an installed platform package if present
let platformPkg = candidates.find((c) => fs.existsSync(nm(c)));

// fallback: try to discover any package starting with "lightningcss-"
if (!platformPkg) {
  try {
    const all = fs.readdirSync(path.join(root, "node_modules"), {
      withFileTypes: true,
    });
    const found = all.find(
      (d) => d.isDirectory() && d.name.startsWith("lightningcss-"),
    );
    if (found) platformPkg = found.name;
  } catch (_e) {
    // ignore
  }
}

// final fallback to the generic name (may fail if not installed)
platformPkg = platformPkg || "lightningcss-win32-x64-msvc";

function findLightningcssDirs(dir) {
  const results = [];
  try {
    for (const name of fs.readdirSync(dir)) {
      const p = path.join(dir, name);
      const stat = fs.statSync(p);
      if (stat.isDirectory()) {
        if (name === "lightningcss") results.push(p);
        // descend into node_modules only to avoid scanning everything
        if (name === "node_modules") {
          results.push(...findLightningcssDirs(p));
        } else {
          // also descend into scoped packages and @tailwindcss folders where nested node_modules may live
          if (
            name.startsWith("@") ||
            name === "@tailwindcss" ||
            name === "node_modules"
          ) {
            results.push(...findLightningcssDirs(p));
          } else {
            // limited depth: check for node_modules inside this folder
            const nmInside = path.join(p, "node_modules");
            if (fs.existsSync(nmInside))
              results.push(...findLightningcssDirs(nmInside));
          }
        }
      }
    }
  } catch (_e) {
    // ignore permission errors
  }
  return results;
}

// search top-level node_modules
const topNodeModules = path.join(root, "node_modules");
if (!fs.existsSync(topNodeModules)) {
  console.error("no node_modules found, aborting shim creation");
  process.exit(0);
}

const dirs = findLightningcssDirs(topNodeModules);
if (dirs.length === 0) {
  // if none found, create the top-level lightningcss pkg location so require('./node_modules/lightningcss') works
  const fallback = path.join(topNodeModules, "lightningcss");
  if (!fs.existsSync(fallback)) fs.mkdirSync(fallback, { recursive: true });
  dirs.push(fallback);
}

for (const dir of dirs) {
  try {
    const pkgDir = path.join(dir, "pkg");
    const index = path.join(pkgDir, "index.js");
    if (!fs.existsSync(index)) {
      fs.mkdirSync(pkgDir, { recursive: true });
      const content = `// auto-generated by scripts/ensure-lightningcss-pkg.js
// redirect to platform package
module.exports = require('${platformPkg}');\n`;
      fs.writeFileSync(index, content, "utf8");
      console.log(`created shim: ${index} -> ${platformPkg}`);
    } else {
      console.log(`pkg/index.js already exists: ${index}`);
    }
  } catch (err) {
    console.warn("failed路to路create路shim路for", dir, err?.message);
  }
}
